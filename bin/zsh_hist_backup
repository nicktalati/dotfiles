#!/bin/bash

set -euo pipefail

XDG_STATE_HOME="${XDG_STATE_HOME:-$HOME/.local/state}"
HIST_FILE="$XDG_STATE_HOME/zsh/history"
BACKUP_DIR="$XDG_STATE_HOME/zsh/backups"
CORRUPT_FLAG="$BACKUP_DIR/.corruption_flag"
LOCK_FILE="$BACKUP_DIR/.hist-backup.lock"
KEEP=10

umask 077
mkdir -p "$BACKUP_DIR"

exec 9>"$LOCK_FILE"
flock -n 9 || exit 0

if [[ ! -f "$HIST_FILE" ]]; then
  printf 'zsh-hist-backup: history file not found: %s\n' "$HIST_FILE" >&2
  exit 2
fi

shopt -s nullglob

backups=( "$BACKUP_DIR"/*.bak )
latest_backup=""
if (( ${#backups[@]} > 0 )); then
    oldIFS=$IFS
    IFS=$'\n' backups_sorted=($(printf '%s\n' "${backups[@]}" | sort -r))
    IFS=$oldIFS
    latest_backup="${backups_sorted[0]}"
fi

timestamp="$(date +%Y-%m-%d-%H-%M-%S)"
dest="$BACKUP_DIR/$timestamp.bak"

if [[ -z "$latest_backup" ]]; then
    cp --preserve=mode "$HIST_FILE" "$dest"
    exit 0
fi

size_hist=$(stat -c%s "$HIST_FILE")
size_prev=$(stat -c%s "$latest_backup")

snap_cond_prune () {
    cp --preserve=mode "$HIST_FILE" "$dest"
    if [[ ! -f "$CORRUPT_FLAG" ]]; then
        if (( "${#backups[@]}" >= "$KEEP" )); then
            rm -f "${backups_sorted[@]:(( $KEEP - 1 ))}"
        fi
    fi
}

if (( size_hist < size_prev )); then
    : > "$CORRUPT_FLAG"
    snap_cond_prune
    exit 0
fi

if cmp -n "$size_prev" -s "$latest_backup" "$HIST_FILE"; then
    if (( size_hist > size_prev )); then
        snap_cond_prune
    fi
    exit 0
fi

: > "$CORRUPT_FLAG"
snap_cond_prune
